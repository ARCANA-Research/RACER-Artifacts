/*
This microkernel perform a single 16-bit matrix-vector multiply with dimension (64) = (64,1344) x (1344)
*/

/*============================= MAIN PROGRAM =================================*/
/*
  (*) Like the matrix multiply counterpart, the 16bmvmulMedium kernel perform
      hard extension on the cluster level, so that it can do easy extension
      on the chip level
  (*) This means m is extended by 64
  (*) The cost of data movement between compute unit is calculated as:
      - Assume the chip clock period is 2.64 ns
      - All power and latency number generated from verilog circuit level simulation
      - Load Latency = 2 COPY (NOR) + 64 READ burst + 64 WRITE + 64 Cluster Wire Delay
                     = 2 x 2.6405 + 64 x 2.64 + 64 x 2.64 + 64 x 1.438
                     = 435.233 ns
      - Load Energy  = Load Latency x Total Power
                     = 435233 (ps) x 0.0079 (W)
                     = 3438.3 (pJ)
     - Because there is only 1 column of output per compute unit, there will be only 1
       LLOAD per compute unit
    (*) Because m = 21, 42 vectors are needed to store A and B
    (*) 1 vector stores the output
    (*) 7 vectors stores intermediate values for the partial sum
    (*) There are 64 - 7 - 1 - 42 = 14 vectors free, we can use these to store partial result
        from other compute unit.
*/

SETBULK 0 64 1

MAC16 h0v42 b0v21 b0v0 1
MAC16 h0v42 b0v22 b0v1 1
MAC16 h0v42 b0v23 b0v2 1
MAC16 h0v42 b0v24 b0v3 1
MAC16 h0v42 b0v25 b0v4 1
MAC16 h0v42 b0v26 b0v5 1
MAC16 h0v42 b0v27 b0v6 1
MAC16 h0v42 b0v28 b0v7 1
MAC16 h0v42 b0v29 b0v8 1
MAC16 h0v42 b0v30 b0v9 1
MAC16 h0v42 b0v31 b0v10 1
MAC16 h0v42 b0v32 b0v11 1
MAC16 h0v42 b0v33 b0v12 1
MAC16 h0v42 b0v34 b0v13 1
MAC16 h0v42 b0v35 b0v14 1
MAC16 h0v42 b0v36 b0v15 1
MAC16 h0v42 b0v37 b0v16 1
MAC16 h0v42 b0v38 b0v17 1
MAC16 h0v42 b0v39 b0v18 1
MAC16 h0v42 b0v40 b0v19 1
MAC16 h0v42 b0v41 b0v20 1

UNSETALL

SETBULK 0 1 1
// LLOAD compute uni 1 to 14 into 0
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3

ADD16 x x x 14 1

// LLOAD compute unit 15 to 29 into 0
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3

ADD16 x x x 14 1

// LLOAD compute unit 30 to 44 into 0
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3

ADD16 x x x 14 1

// LLOAD compute uni 45 to 59 into 0
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3

ADD16 x x x 14 1

// LLOAD compute uni 60 to 63 into 0
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3
SHIFT 435.233 3438.3

ADD16 x x x 4 1
UNSETALL
